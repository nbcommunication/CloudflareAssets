<?php namespace ProcessWire;

/**
 * Cloudflare Assets
 *
 * #pw-summary Extends Pagefile to use Cloudflare Images, Stream and R2 storage to serve files.
 *
 * @copyright 2023 NB Communication Ltd
 * @license Mozilla Public License v2.0 http://mozilla.org/MPL/2.0/
 *
 * @property string $accountId
 * @property string $accessToken
 * @property string $domain
 * @property string $bucket
 * @property string $accessKeyId
 * @property string $secretAccessKey
 * @property string $customerSubdomain
 * @property string $allowedOriginsList
 * @property string $accountHash
 * @property bool $imageDelivery
 * @property bool $onlyUploads
 *
 * @property array $allowedOrigins
 * @property S3Client $s3
 * @property array $usage
 *
 */

class CloudflareAssets extends WireData implements Module, ConfigurableModule {

	/**
	 * getModuleInfo is a module required by all modules to tell ProcessWire about them
	 *
	 * @return array
	 *
	 */
	public static function getModuleInfo() {
		return [
			'title' => 'Cloudflare Assets',
			'version' => 15,
			'summary' => 'Extends Pagefile to use Cloudflare Images, Stream and R2 storage to serve files.',
			'author' => 'nbcommunication',
			'href' => 'https://github.com/nbcommunication/CloudflareAssets',
			'singular' => true,
			'autoload' => true,
			'icon' => 'cloud',
			'requires' => 'ProcessWire>=3.0.210,PHP>=8.1.0',
		];
	}

	const formDataBoundary = '---011000010111000001101001';
	const imageVariantPrefix = 'iv:';
	const maxVariants = 100;
	const streamExtensions = 'mp4 mkv mov avi flv webm mpg';

	/**
	 * An array of allowed origins for Streams
	 *
	 * @var array
	 *
	 */
	protected $allowedOrigins = [];

	/**
	 * The AWS S3 client
	 *
	 * @var S3Client
	 *
	 */
	protected $s3 = null;

	/**
	 * The 'cached' usage statistics
	 *
	 * @var array
	 *
	 */
	protected $usage = [];

	/**
	 * Should the save hook keep running?
	 *
	 * @var array
	 *
	 */
	protected $runSaveHook = true;

	/**
	 * Initialize the module
	 *
	 */
	public function init() {

		// We need these details to proceed
		if($this->accountId && $this->bucket && $this->accessKeyId && $this->secretAccessKey) {

			require_once __DIR__ . '/vendor/autoload.php';

			try {

				// Create the client
				$this->s3 = new \Aws\S3\S3Client([
					'region' => 'auto',
					'endpoint' => "https://{$this->accountId}.r2.cloudflarestorage.com",
					'version' => 'latest',
					'credentials' => new \Aws\Credentials\Credentials($this->accessKeyId, $this->secretAccessKey),
				]);

				// Use the stream wrapper (native PHP functions)
				$this->s3->registerStreamWrapperV2();

				// If the bucket does not exist, create it
				if(!$this->s3->doesBucketExistV2($this->bucket)) {
					$this->s3->createBucket([
						'Bucket' => $this->bucket,
					]);
				}

			} catch(\Aws\S3\Exception\S3Exception $e) {

				$this->log($e->getMessage());

			} catch(\Aws\Exception\AwsException $e) {

				$this->log($e->getMessage());
			}
		}

		// Set the allowed origins for streams
		$this->allowedOriginsList = trim($this->allowedOriginsList);
		if($this->allowedOriginsList) {
			$this->allowedOrigins = array_map(function($line) {
				return trim($line);
			}, explode("\n", $this->allowedOriginsList));
		}
	}

	/**
	 * When ProcessWire is ready
	 *
	 */
	public function ready() {

		// If authenticated with R2 and we have an API access token
		if($this->s3 && $this->accessToken) {

			$cache = $this->wire()->cache;

			// Verify the credentials
			$cacheKey = md5($this->accountId . $this->accessToken);
			$tokenVerified = $cache->getFor($this, $cacheKey);
			if(!$tokenVerified) {
				$response = $this->apiRequest();
				if($response['result']['status'] ?? '' === 'active') {
					$tokenVerified = true;
					$cache->saveFor($this, $cacheKey, 1, WireCache::expireNever);
				} else {
					// Remove access token
					$this->log($this->_('Sorry, the Account ID / Access Token you provided is invalid.'));
					$this->wire()->modules->saveConfig($this, 'accountId', '');
					$this->wire()->modules->saveConfig($this, 'accessToken', '');
				}
			}

			// If authenticated, attach hooks
			if($tokenVerified) {

				// If not the admin
				if($this->wire()->page->template->name !== 'admin' && strpos($this->wire()->page->url, $this->wire()->config->urls->admin) !== 0) {

					// If not upload only mode
					if(!$this->onlyUploads) {
						// Check for variations that need to be removed
						$cacheName = 'removeVariations';
						$toRemove = $cache->getFor($this, $cacheName) ?? [];
						if(is_array($toRemove) && count($toRemove)) {
							foreach($toRemove as $filename) {
								$this->wire()->files->unlink($filename);
							}
							$cache->deleteFor($this, $cacheName);
						}
					}

					// Make sure an image is present to be resized
					$this->addHookBefore('Pageimage::size()', $this, 'hookPageimageSize');

					// Replace local URLs with Cloudflare ones
					$this->addHook('Pagefile::url()', $this, 'hookPagefileUrl');
					$this->addHook('Pagefile::httpUrl()', $this, 'hookPagefileHttpUrl');

					// After a variation is created +CloudFlare
					// This is not required for the admin side as it does not serve Cloudflare URLs
					$this->addHook('Pageimage::createdVariation', $this, 'hookPageimageCreatedVariation');

					// When rendering the page, look for local links that should be replaced with Cloudflare links
					$this->addHookAfter('Page::render', $this, 'hookPageRender', ['priority' => 199]);
				}

				// Utility properties
				$this->addHookProperty('Pagefile::localUrl', $this, 'hookPagefileLocalUrl');
				$this->addHookProperty('Pagefile::localHttpUrl', $this, 'hookPagefileLocalHttpUrl');
				$this->addHookProperty('Pagefile::r2Key', $this, 'hookPagefileR2Key');
				$this->addHookProperty('Pagefile::r2Path', $this, 'hookPagefileR2Path');

				// When a file is uploaded +CloudFlare
				$this->addHookAfter('PagefilesManager::save', $this, 'hookPagefilesManagerSave');

				// When a page is finished being saved, set the runSaveHook property to false
				$this->addHookAfter('Pages::save', function(HookEvent $event) {
					$this->runSaveHook = true;
				});

				// When a file input is rendered, check file availability
				$this->addHookBefore('InputfieldFile::render', $this, 'hookInputfieldFileRender');

				// When a page is deleted remove all Cloudflare assets
				$this->addHookBefore('Pages::cloned', $this, 'hookPagesCloned');

				// When a page is deleted remove all Cloudflare assets
				$this->addHookBefore('Pages::delete', $this, 'hookPagesDelete');

				// When a file is removed, -Cloudflare
				$this->addHookAfter('Pagefiles::delete', $this, 'hookPagefilesDelete');
			}
		}
	}

	/**
	 * Send a request to the Cloudflare API
	 *
	 * @param string $endpoint
	 * @param array|string $data
	 * @param string $method
	 * @param bool $logErrors
	 * @return array
	 *
	 */
	public function apiRequest($endpoint = '', $data = [], $method = 'POST', $logErrors = true) {

		$profiler = $this->profilerStart('apiRequest');

		$http = $this->wire(new WireHttp());

		if($endpoint) {
			$endpoint = "accounts/{$this->accountId}/$endpoint";
		} else {
			$endpoint = 'user/tokens/verify';
			$method = 'GET';
		}

		$contentType = 'application/json';
		if(!is_array($data)) {
			$contentType = 'multipart/form-data; boundary=' . self::formDataBoundary;
		} else if(count($data)) {
			$data = json_encode($data);
		}

		$response = $http
			->setTimeout(20)
			->setHeaders([
				'Authorization' => "Bearer {$this->accessToken}",
				'Content-Type' => $contentType,
			])
			->send(
				"https://api.cloudflare.com/client/v4/$endpoint",
				$data,
				$method,
				['use' => 'curl']
			);

		$response = $response ? (json_decode($response, 1) ?? [$response]) : [];
		if(!($response['success'] ?? false) && $logErrors) {
			$this->log(json_encode($response));
		}

		$this->profilerStop($profiler);

		return $response;
	}

	/**
	 * Hook Pageimage::size()
	 *
	 * Skip variation creation if we have the variant in Cloudflare
	 * Or make sure an image is present to be resized
	 *
	 * @param HookEvent $event
	 *
	 */
	public function hookPageimageSize(HookEvent $event) {

		$pageimage = $event->object;
		$width = (int) $event->arguments(0);
		$height = (int) $event->arguments(1);
		$options = $event->arguments(2);

		if($this->uid($pageimage) && ($options['cfImageVariant'] ?? false)) {

			// A Cloudflare variant is requested

			$cfVariant = $this->getCloudflareVariant($width, $height, $options)['name'] ?? '';
			if($cfVariant) {

				$variants = $this->getUsageStatistics()['variants'] ?? [];
				if(count($variants) && in_array($cfVariant, $variants)) {

					// If the variant name is in the list of variants

					// Get the basename for this variant so we can check whether we need to update the filedata
					// The crop
					$crop = '';
					if(
						is_string($options['cropping'] ?? null) &&
						!(
							strpos($options['cropping'], 'x') === 0 &&
							preg_match('/^x(\d+)[yx](\d+)/', $options['cropping'], $matches)
						)
					) {
						$crop = ImageSizer::croppingValueStr($options['cropping']);
					}

					// The suffix
					$suffixStr = '';
					if(!is_array($options['suffix'] ?? [])) {
						// convert to array
						$options['suffix'] = empty($options['suffix']) ? array() : explode(' ', $options['suffix']);
					}
					if(!empty($options['suffix'])) {
						$suffix = $options['suffix'];
						sort($suffix);
						foreach($suffix as $key => $s) {
							$s = strtolower($this->wire()->sanitizer->fieldName($s));
							if(empty($s)) {
								unset($suffix[$key]);
							} else {
								$suffix[$key] = $s;
							}
						}
						if(count($suffix)) $suffixStr = '-' . implode('-', $suffix);
					}
					if($options['hidpi'] ?? false) {
						$suffixStr .= '-hidpi';
					}

					$basename = implode('.', [
						basename($pageimage->basename, '.' . $pageimage->ext),
						(is_int($options['nameWidth'] ?? '') ? $options['nameWidth'] : $width) .
						'x' .
						(is_int($options['nameHeight'] ?? '') ? $options['nameHeight'] : $height) .
						$crop .
						$suffixStr,
						$pageimage->ext
					]);

					// Create the 'variation'
					$pageimageNew = clone $pageimage;
					$pageimageNew->setFilename($pageimage->pagefiles->path() . $basename);
					$pageimageNew->setOriginal($pageimage);
					$pageimageNew->set('variationWidth', $width);
					$pageimageNew->set('variationHeight', $height);

					if(!$this->uidVariant($pageimage, $basename)) {

						// We need to add the variant to the filedata of the original
						// and to the clone so it is available immediately
						$pageimageNew = $this->setFiledataImmediately($pageimageNew, self::imageVariantPrefix . $cfVariant);
						$this->resetUsage('images');
					}

					// Skip the variation creation
					$event->replace = true;
					$event->return = $pageimageNew;

					return;
				}
			}
		}

		if(!file_exists($pageimage->filename)) {
			$this->downloadRemoteFile($pageimage);
		}
	}

	/**
	 * Hook Pagefile::url()
	 *
	 * Output the Cloudflare URL (if enabled)
	 *
	 * @param HookEvent $event
	 * @return string
	 *
	 */
	public function hookPagefileUrl(HookEvent $event) {

		$pagefile = $event->object;

		if($this->onlyUploads) {

			// Make sure the file is available locally
			// If not, get it
			if(!file_exists($pagefile->filename)) {
				$this->downloadRemoteFile($pagefile);
			}

		} else {

			// Serve the appropriate Cloudflare url
			$uid = $this->uid($pagefile);
			if($uid && !$this->getLocal) {

				$url = $this->getCloudflareUrl();
				if($this->useImages($pagefile)) {

					$variant = '';
					if(!$pagefile->original || $pagefile === $pagefile->original) {
						$variant = 'public';
					} else {
						$v = $this->uidVariant($pagefile);
						if($v) {
							$variant = $v;
							if($this->isImageVariant($variant)) {
								$variant = $this->getImageVariantName($variant);
							} else {
								// The variant was uploaded directly
								$uid = $variant;
								$variant = 'public';
							}
						} else {
							// The Cloudflare variant does not exist or is not stored for this image
							// We will remove the variation image so that it is regenerated next time
							$cache = $this->wire()->cache;
							$cacheName = 'removeVariations';
							$toRemove = $cache->getFor($this, $cacheName) ?? [];
							$toRemove[$pagefile->basename] = $pagefile->filename;
							$cache->saveFor($this, $cacheName, $toRemove);
						}
					}

					if($variant) {
						$image = "{$this->accountHash}/$uid/$variant";
						if($this->imageDelivery) {
							$url = "https://imagedelivery.net/$image";
						} else {
							$url .= "/cdn-cgi/imagedelivery/$image";
						}
					} else {
						$url = ''; // Use the local URL
					}

				} else if($this->useStream($pagefile)) {

					// Get/set the video dimensions if they are not already set
					$filedata = $pagefile->filedata();
					$width = $filedata['width'] ?? -1;
					$height = $filedata['height'] ?? -1;
					if($width < 0 || $height < 0) {
						$response = $this->apiRequest("stream/$uid", [], 'GET');
						$pagefile->page->of(false);
						foreach($response['result']['input'] ?? [] as $key => $value) {
							$pagefile->filedata($key, $value);
						}
						$this->saveQuietly($pagefile);
					}

					$url = "https://{$this->customerSubdomain}/$uid/iframe";


				} else {

					$url .= "/$uid";
				}

				if($url) {
					$event->replace = true;
					$event->return = $url;
				}
			}
		}
	}

	/**
	 * Hook Pagefile::httpUrl()
	 *
	 * Output the Cloudflare URL (if enabled)
	 * url() and httpUrl() are the same as the Cloudflare URL is not local
	 *
	 * @param HookEvent $event
	 * @return string
	 *
	 */
	public function hookPagefileHttpUrl(HookEvent $event) {

		$pagefile = $event->object;

		if($this->onlyUploads) {

			// Make sure the file is available locally
			// If not, get it
			if(!file_exists($pagefile->filename)) {
				$this->downloadRemoteFile($pagefile);
			}

		} else {

			// Serve the appropriate Cloudflare url
			$uid = $this->uid($pagefile);
			if($uid && !$this->getLocal) {
				$url = $event->object->url();
				if(strpos($url, '://') !== false) {
					$event->replace = true;
					$event->return = $url;
				}
			}
		}

	}

	/**
	 * Hook Pagefile::hookPagefileLocalUrl()
	 *
	 * Return the local URL of the asset
	 *
	 * @param HookEvent $event
	 * @return $this
	 *
	 */
	public function hookPagefileLocalUrl(HookEvent $event) {
		$this->set('getLocal', true);
		$url = $event->object->url;
		$this->set('getLocal', $this->onlyUploads);
		$event->return = $url;
	}

	/**
	 * Hook Pagefile::hookPagefileLocalHttpUrl()
	 *
	 * Return the full local URL of the asset
	 *
	 * @param HookEvent $event
	 * @return $this
	 *
	 */
	public function hookPagefileLocalHttpUrl(HookEvent $event) {
		$this->set('getLocal', true);
		$httpUrl = $event->object->httpUrl;
		$this->set('getLocal', $this->onlyUploads);
		$event->return = $httpUrl;
	}

	/**
	 * Hook Pagefile::r2Key
	 *
	 * Return the R2 'Key' for this Pagefile
	 *
	 * @param HookEvent $event
	 * @return string
	 *
	 */
	public function hookPagefileR2Key(HookEvent $event) {
		$event->return = "{$event->object->page->id}/{$event->object->basename}";
	}

	/**
	 * Hook Pagefile::r2Path
	 *
	 * Return the R2 'Path' for this Pagefile
	 *
	 * @param HookEvent $event
	 * @return string
	 *
	 */
	public function hookPagefileR2Path(HookEvent $event) {
		$event->return = "s3://{$this->bucket}/{$event->object->r2Key}";
	}

	/**
	 * Hook PagefilesManager::save
	 *
	 * After files are added, add it to the appropriate Cloudflare service
	 *
	 * @param HookEvent $event
	 * @return string
	 *
	 */
	public function hookPagefilesManagerSave(HookEvent $event) {

		if($this->runSaveHook) {

			$page = $event->object->page;
			foreach($page as $value) {

				if($value instanceof Pagefiles && $page->isChanged($value->field->name)) {

					$count = $value->count();
					if($count) {

						foreach($value as $pagefile) {

							$uid = $this->uid($pagefile);
							if($uid && $this->useStream($pagefile)) {

								// If a video file which already exists
								// Check if we need to update the name from the description

								$response = $this->apiRequest(
									"stream/$uid",
									[],
									'GET'
								);

								if($response['success'] ?? false) {

									$label = $this->getLabel($pagefile);
									if($label !== ($response['result'][0]['meta']['name'] ?? '')) {
										$this->apiRequest(
											"stream/$uid",
											[
												'meta' => [
													'name' => $label,
												],
												'allowedOrigins' => $this->allowedOrigins,
											]
										);
									}

								} else {
									// Not found, check the log for details
								}

							} else {

								$add = true;
								if($value->field->maxFiles === 1 && $count > 1) {

									$this->runSaveHook = false;

									// A new file has been added to a single item field
									if($pagefile === $value->last) {

										// Remove the existing key from the filedata as we want this item uploaded
										$pagefile = $this->removeUids($pagefile);

									} else {

										// This is the first item which will be replaced
										$this->removeFromCloudflare($pagefile);
										$add = false;
									}
								} else {
									$this->runSaveHook = true;
								}

								// Add to Cloudflare if not already added
								if($add) {
									$this->addToCloudflare($pagefile);
								}
							}
						}
					}
				}
			}
		}
	}

	/**
	 * Hook InputfieldFile::render
	 *
	 * When a file input is rendered, check file availability.
	 * If the file does not exist locally, get it from R2.
	 * If the file exists locally but not remotely, add it to R2
	 *
	 * @param HookEvent $event
	 *
	 */
	public function hookInputfieldFileRender(HookEvent $event) {

		if($event->object->value instanceof Pagefiles && $event->object->value->count) {

			foreach($event->object->value as $pagefile) {

				$localFile = $pagefile->filename;
				$remoteFile = $pagefile->r2Path;
				$hasLocalFile = file_exists($localFile);
				$hasRemoteFile = file_exists($remoteFile);

				if(!$this->uid($pagefile) || ($hasLocalFile && !$hasRemoteFile)) {

					// Add the file to Cloudflare
					$this->addToCloudflare($pagefile);

					// Save quietly so id can be saved in filedata
					$this->saveQuietly($pagefile);

				} else if(!$hasLocalFile && $hasRemoteFile) {

					// Get the file from R2 and save it locally
					$this->downloadRemoteFile($pagefile);
				}
			}
		}
	}

	/**
	 * Hook Pages::cloned
	 *
	 * When a page is cloned, add all file assets to Cloudflare
	 *
	 * @param HookEvent $event
	 *
	 */
	public function hookPagesCloned(HookEvent $event) {
		foreach($event->arguments('copy')->getFields() as $field) {
			if($field->type instanceof FieldtypeFile) {
				foreach($event->arguments('page')->get($field->name) as $pagefile) {
					// Remove the existing key from the filedata
					// Add the assets to Cloudflare and save the filedata
					$pagefile->page->of(false);
					$pagefile->filedata(null, $this->className);
					$this->addToCloudflare($pagefile);
					$this->saveQuietly($pagefile);
				}
			}
		}
	}

	/**
	 * Hook Pages::delete
	 *
	 * When a page is deleted, remove all file assets from Cloudflare
	 *
	 * @param HookEvent $event
	 *
	 */
	public function hookPagesDelete(HookEvent $event) {

		$page = $event->arguments('page');

		$of = $page->of();
		$page->of(false);
		foreach($page->getFields() as $field) {
			if($field->type instanceof FieldtypeFile) {
				foreach($page->get($field->name) as $pagefile) {
					$this->removeFromCloudflare($pagefile);
				}
			}
		}
		$page->of($of);
	}

	/**
	 * Hook Pagefiles::delete
	 *
	 * When a file is deleted, remove it from Cloudflare
	 *
	 * @param HookEvent $event
	 *
	 */
	public function hookPagefilesDelete(HookEvent $event) {
		$this->removeFromCloudflare($event->arguments(0));
	}

	/**
	 * Hook Pageimage::createdVariation()
	 *
	 * @param HookEvent $event
	 * @return string
	 *
	 */
	public function hookPageimageCreatedVariation(HookEvent $event) {

		$pageimage = $event->arguments(0);
		$data = $event->arguments(1);

		if($this->useImages($pageimage) && $this->uid($pageimage) && !$this->uidVariant($pageimage)) {

			$profiler = $this->profilerStart('createdVariation');

			$options = $data['options'];
			$dryRun = $options['dryRun'] ?? false;
			if($dryRun) {
				$dryRun = "{$this->className}_{$pageimage->basename}";
			}

			// For the Cloudflare variant to be created/used
			// The cfImageVariant must be passed as true in the size options

			if($options['cfImageVariant'] ?? false) {

				// Create a Cloudflare Variant

				$cache = $this->wire()->cache;
				$config = $this->wire()->config;

				$cfVariantData = $this->getCloudflareVariant((int) $data['width'], (int) $data['height'], $options);
				$cfVariant = $cfVariantData['name'];
				$cfVariantOptions = $cfVariantData['options'];

				$uidVariant = self::imageVariantPrefix . $cfVariant;

				// Get the variant usage
				$usage = $this->getUsageStatistics();

				// If the number of variants is approaching the maximum (4/5 used), notify the admin
				$maxVariants = self::maxVariants;
				$numVariants = $usage['variantsCount'];
				if($numVariants / $maxVariants > 0.8) {

					$cache->getFor($this, 'totalVariantsNotifyAdmin', 'daily', function() use ($config, $maxVariants, $numVariants) {

						$warning = sprintf(
							$this->_('The number of variants you have used (%1$d) is approaching the maximum of %2$d.'),
							$numVariants,
							$maxVariants
						);

						$this->log($warning);

						$adminEmail = $config->adminEmail;
						if($adminEmail) {
							$this->wire()->mail->new()
								->to($adminEmail)
								->subject(sprintf($this->_('%1$s on %2$s'), $this->className, $config->httpHost))
								->body($warning)
								->send();
							return 2; // logged and email sent
						}

						return 1; // only logged
					});
				}

				if($dryRun) {

					// Log the expected result

					if(!in_array($cfVariant, $usage['variants'])) {
						$this->log(sprintf($this->_('Dry run: the image would create a Cloudflare Images Variant named `%s`'), $cfVariant));
					}

					$this->log(sprintf($this->_('Dry run: the image would use a Cloudflare Images Variant named `%1$s` with the filedata key `%2$s`'), $cfVariant, "$dryRun: $uidVariant"));
					$uidVariant = null;

				} else if(!in_array($cfVariant, $usage['variants'])) {

					// If the variant does not exist
					// Create the variant
					$response = $this->apiRequest(
						'images/v1/variants',
						[
							'id' => $cfVariant,
							'options' => $cfVariantOptions,
						],
					);
					$this->resetUsage('variants');
				}

			} else if($dryRun) {

				// Log the expected result
				$this->log(sprintf($this->_('Dry run: an image variation would be uploaded with the filedata key `%s`'), "$dryRun: {CFUID}"));

			} else {

				// Upload as a new image
				$uid = $this->addImageToCloudflare($pageimage);
				if($uid) {
					$uidVariant = $uid;
				} else {
					$this->log(sprintf($this->_('Could not upload %s. Please remove and try again.'), $pageimage->basename));
				}
			}

			if($uidVariant ?? '') {
				// We need to add the variant to the filedata of the original
				// and to the clone so it is available immediately
				$pageimage = $this->setFiledataImmediately($pageimage, $uidVariant);
				$this->resetUsage('images');
			}

			$this->profilerStop($profiler);
		}
	}

	/**
	 * Add the file to Cloudflare
	 *
	 * @param Pagefile $pagefile
	 * @return string|null
	 *
	 */
	public function addToCloudflare(Pagefile $pagefile) {

		$uid = $this->uid($pagefile);

		if(!$uid) {

			$r2Url = $this->getCloudflareUrl() . "/$pagefile->r2Key";

			// All uploaded files are placed in R2 via s3 client
			if(file_put_contents($pagefile->r2Path, fopen($pagefile->filename, 'r'))) {
				$uid = $pagefile->r2Key;
			}

			if($uid) {

				if($this->useImages($pagefile)) {

					// Add the image to Cloudflare Images
					$uid = $this->addImageToCloudflare($pagefile, $r2Url);

					if($uid) { // reset usage statistics
						$this->resetUsage('images');
					}

				} else if($this->useStream($pagefile)) {

					// Add the video to Cloudflare Stream
					$response = $this->apiRequest(
						'stream/copy',
						[
							'url' => $r2Url,
							'meta' => [
								'name' => $this->getLabel($pagefile),
							],
							'allowedOrigins' => $this->allowedOrigins,
						]
					);

					$uid = $response['result']['uid'] ?? null;

					if($uid) { // reset usage statistics
						$this->resetUsage('stream');
					}
				}
			}

			// Set the uid if present
			if($uid ?? '') {
				$this->uid($pagefile, $uid);
			}
		}

		return $uid;
	}

	/**
	 * Hook called after a page is rendered
	 *
	 * Look for local links that should be replaced with Cloudflare links
	 *
	 * @param HookEvent $event
	 *
	 */
	public function hookPageRender(HookEvent $event) {

		$page = $event->object;

		$contentType = $page->template->contentType;
		$isHTML = !$contentType || $contentType === 'html' || $contentType === 'text/html';
		if($isHTML) $isHTML = stripos($event->return, '</html>') !== false;
		$out = $event->return;

		if($isHTML) {

			$urlFiles = $this->wire()->config->urls('files');

			if(preg_match_all(
				'/="(' . str_replace('/', '\/', $urlFiles) . '\d+\/.*?)"/',
				$out,
				$matches
			)) {

				$profiler = $this->profilerStart('pageRender');

				$fileFields = [];
				$replacements = [];

				foreach($matches[0] as $key => $fullMatch) {

					$matchUrl = $matches[1][$key];

					// If the file exists somewhere outside our files, skip
					if(strpos($matchUrl, $urlFiles) !== 0) continue;

					// Determine page id that owns file from its URL
					$id = str_replace($urlFiles, '', dirname($matchUrl));

					// If extended paths are in use, remove slashes
					if(strpos($id, '/') !== false) $id = str_replace('/', '', $id);

					// Get page from the id
					$id = (int) $id;
					$p = $id === $page->id ? $page : $this->wire()->pages->get($id);

					// If the page isn't a page, skip
					if(!$p->id) continue;

					// Get the image fields for this page
					if(!isset($fileFields[$p->id])) {

						$fileFields[$p->id] = [];

						foreach($p->template->fieldgroup as $field) {
							if(!$field->type instanceof FieldtypeFile && !$field->type instanceof FieldtypeImage) continue;
							$v = $p->get($field->name);
							if(empty($v)) continue;
							if($v instanceof Pagefile) $v = $v->pagefiles;
							if(!$v instanceof Pagefiles) continue;
							if(!$v->count()) continue;
							$fileFields[$p->id][$field->name] = $v;
						}
					}

					$pagefile = null;
					$filename = basename($matchUrl);

					foreach($fileFields[$p->id] as $fileField) {
						$pagefile = $fileField->getFile($filename);
						if($pagefile) break;
					}

					if($pagefile && $pagefile instanceof Pagefile && $this->uid($pagefile)) {

						if($pagefile instanceof Pageimage) {
							// Resize if a variation
							if(preg_match('/\.(\d+)x(\d+)(.*?)\./', $filename, $dimensions)) {
								$pagefile = $pagefile->size((int) $dimensions[1] ?: 0, (int) $dimensions[2] ?: 0, [
									'hidpi' => strpos($dimensions[3] ?? '', 'hidpi') !== false,
								]);
							}
							$replacements[$matchUrl] = $pagefile->url;
						} else {
							$replacements[$matchUrl] = $pagefile->url;
						}
					}
				}

				if(count($replacements)) {
					$out = str_replace(array_keys($replacements), array_values($replacements), $out);
				}

				$this->profilerStop($profiler);
			}

			$event->return = $out;
		}
	}

	/**
	 * Get the image Cloudflare Variant name
	 *
	 * @param int $width
	 * @param int $height
	 * @param array $options
	 * @return string
	 *
	 */
	public function ___getCloudflareVariant($width, $height, $options = []) {

		// is set and is int
		$_issetInt = function($a, $b) {
			return isset($a[$b]) && is_int($a[$b]);
		};

		// is center
		$_isCenter = function($x, $y) {
			return $x === 0.5 && $y === 0.5;
		};

		// Cloudflare Image settings
		$cfVariantOptions = [
			'fit' => !$width || !$height ?
				'contain' :
				($options['upscaling'] ?? true ? // PW default is true
					'cover' :
					'crop'
				),
		];

		if($width) {
			$cfVariantOptions['width'] = $width;
		}

		if($height) {
			$cfVariantOptions['height'] = $height;
		}

		// Focus point not used
		/*// Focus point -> Gravity
		$focus = $pageimage->focus();
		if($focus) {
			$x = (float) $focus['left'] / 100;
			$y = (float) $focus['top'] / 100;
			if(!$_isCenter($x, $y)) {
				$cfVariantOptions['gravity'] = [
					'x' => $x,
					'y' => $y,
				];
			}
		}*/

		// Cropping
		if(isset($options['cropping'])) {
			if(
				(is_bool($options['cropping']) && !$options['cropping']) ||
				(is_string($options['cropping']) && empty($options['cropping']))
			) {

				// No cropping
				$cfVariantOptions['fit'] = 'scale-down';

			} else if(is_string($options['cropping'])) {

				// Convert string crop to xy
				$x = 0.5;
				$y = 0.5;
				switch($options['cropping']) {
					case 'north':
					case 'n':
						$y = 0;
						break;
					case 'northwest':
					case 'nw':
						$x = 0;
						$y = 0;
						break;
					case 'northeast':
					case 'ne':
						$x = 1;
						$y = 0;
						break;
					case 'south':
					case 's':
						$y = 1;
						break;
					case 'southwest':
					case 'sw':
						$x = 0;
						$y = 1;
						break;
					case 'southeast':
					case 'se':
						$x = 1;
						$y = 1;
						break;
					case 'west':
					case 'w':
						$x = 0;
						break;
					case 'east':
					case 'e':
						$x = 1;
						break;
				}

				if(!$_isCenter($x, $y)) {
					$cfVariantOptions['gravity'] = [
						'x' => $x,
						'y' => $y,
					];
				}
			}
		}

		if(
			// gravity passed directly as an option
			isset($options['gravity']) &&
			(
				(
					// is a valid string value
					is_string($options['gravity']) &&
					in_array($options['gravity'], [
						'auto',
						'left',
						'right',
						'top',
						'bottom',
					])
				) ||
				(
					// or is a valid xy value and not center
					is_array($options['gravity']) &&
					($_issetInt($options['gravity'], 'x') && $options['gravity']['x'] <= 1) &&
					($_issetInt($options['gravity'], 'y') && $options['gravity']['y'] <= 1) &&
					!$_isCenter($options['gravity']['x'], $options['gravity']['y'])
				)
			)
		) {
			$cfVariantOptions['gravity'] = $options['gravity'];
		}

		// HiDPI -> DPR
		if($options['hidpi'] ?? false) {
			$cfVariantOptions['dpr'] = 2;
			$cfVariantOptions['fit'] = 'cover';
			/*
			// For the future perhaps
			// ERROR 5400: Bad request: Variant options do not allow quality
			if(isset($options['hidpiQuality'])) {
				$cfVariantOptions['quality'] = $options['hidpiQuality'];
			}
			*/
		}

		// Sharpening -> Sharpen
		if($options['sharpening'] ?? '') {
			$cfVariantOptions['sharpen'] = [
				'none' => 0,
				'soft' => 0.25,
				'medium' => 0.5,
				'strong' => 0.8,
			][$options['sharpening']] ?? 0.25; // PW default is soft
		}

		// We also need to generate a variant name
		// There's a limit of 100 alphanumeric chars
		// and we also want it to be readable/understandable
		// e.g. we can tell what the variant is doing
		$cfVariantName = [];

		// Convert array or possible values to a string for the variant name
		$_a2s = function($a, $b = false) {
			if(is_array($a)) {
				$s = '';
				if($b) {
					return json_encode($a);
				} else {
					foreach($a as $k => $v) {
						$s .= substr($k, 0, 1) . $v;
					}
				}
				return $s;
			}
			return $a;
		};

		// Bool values
		if(isset($options['anim'])) {
			$cfVariantOptions['anim'] = (bool) $options['anim'];
			$cfVariantName['an'] = (int) $options['anim'];
		}

		// Integer values
		foreach([
			'blur',
			'dpr',
			'height',
			//'quality',
			'rotate',
			'width',
		] as $key) {
			if(isset($options[$key])) {
				$value = (int) $options[$key];
				if($value) {
					$cfVariantOptions[$key] = $value;
					if(!in_array($key, ['width', 'height'])) {
						$cfVariantName[$key] = $value;
					}
				}
			}
		}

		// Float values
		foreach([
			'brightness',
			'contrast',
			'gamma',
			'sharpen',
		] as $key) {
			if(isset($options[$key])) {
				$value = (float) $options[$key];
				if($value) {
					$max = $key === 'sharpen' ? 10 : 2;
					if($value > $max) {
						$value = $max;
					}
					$cfVariantOptions[$key] = $value;
					$cfVariantName[$key] = $value;
				}
			}
		}

		// String values
		foreach([
			'background',
			'fit',
			'metadata',
		] as $key) {
			if(isset($options[$key])) {
				$value = (string) $options[$key];
				if($value) {
					$cfVariantOptions[$key] = $value;
					if($key !== 'fit') {
						$cfVariantName[$key] = $value;
					}
				}
			}
		}

		// Border
		if(
			isset($options['border']) &&
			is_array($options['border']) &&
			isset($options['border']['color']) &&
			is_string($options['border']['color']) &&
			(
				$_issetInt($options['border'], 'width') ||
				(
					$_issetInt($options['border'], 'top') &&
					$_issetInt($options['border'], 'right') &&
					$_issetInt($options['border'], 'bottom') &&
					$_issetInt($options['border'], 'left')
				)
			)
		) {
			$cfVariantOptions['border'] = $options['border'];
			$cfVariantName['bo'] = $_a2s($options['border']);
		}

		// Trim
		if(
			isset($options['trim']) &&
			$_issetInt($options['trim'], 'top') &&
			$_issetInt($options['trim'], 'right') &&
			$_issetInt($options['trim'], 'bottom') &&
			$_issetInt($options['trim'], 'left')
		) {
			$cfVariantOptions['trim'] = $options['trim'];
			$cfVariantName['tr'] = $_a2s($options['trim']);
		}

		// Let's generate the actual variant name
		// e.g. w100h100con
		$cfVariant = 'w' . ($_issetInt($options, 'nameWidth') ? $options['nameWidth'] : ($cfVariantOptions['width'] ?? 0)) .
			'h' . ($_issetInt($options, 'nameHeight') ? $options['nameHeight'] : ($cfVariantOptions['height'] ?? 0)) .
			substr($cfVariantOptions['fit'], 0, 3);

		// e.g. x1y0
		if(isset($cfVariantOptions['gravity'])) {
			$cfVariant .= $_a2s($cfVariantOptions['gravity'], true);
		}

		// e.g. br1sh2
		foreach($cfVariantName as $key => $value) {
			$cfVariant .= substr($key, 0, 2) . $value;
		}

		// e.g. srcset
		if(isset($options['suffix']) && !empty($options['suffix'])) {
			$cfVariant .= $_a2s($options['suffix'], true);
		}

		return [
			// The variant name must be alphanumeric and no longer than 100 chars
			'name' => substr($this->wire()->sanitizer->alphanumeric($cfVariant), 0, 100),
			'options' => $cfVariantOptions,
		];
	}

	/**
	 * Get the Cloudflare URL
	 *
	 * @return string
	 *
	 */
	public function getCloudflareUrl() {
		$url = $this->domain;
		if(strpos($url, '://') === false) {
			$url = "https://$url";
		}
		return $url;
	}

	/**
	 * Get the usage statistics
	 *
	 * @return array
	 *
	 */
	public function getUsageStatistics() {

		if(count($this->usage)) {
			return $this->usage;
		}

		$cache = $this->wire()->cache;

		$_getRecords = function($name, $variants = false) {
			$table = strtolower("field_$name");
			$query = $this->wire()->database->prepare("SELECT filedata FROM $table");
			$query->execute();
			$records = $variants ? [] : [[], []];
			foreach($query->fetchAll(\PDO::FETCH_ASSOC) as $row) {
				foreach(json_decode($row['filedata'], 1) as $key => $value) {
					if(strpos($key, $this->className) === 0) {
						if($variants) {
							if($this->isImageVariant($value)) {
								$records[] = $this->getImageVariantName($value);
							} else if($key === $this->className) {
								$records[] = 'public';
							}
						} else {
							$records[$key === $this->className ? 0 : 1][] = $value;
						}
					}
				}
			}
			return $records;
		};

		$images = $cache->getFor($this, 'usageImages', WireCache::expireNever, function() use ($_getRecords) {

			$counts = $this->apiRequest('images/v1/stats', [], 'GET', false)['result']['count'] ?? [];

			$items = [];
			$counts['missed'] = 0;
			$counts['duplicate'] = 0;
			$counts['variations'] = 0;
			foreach($this->wire()->fields->findByType('FieldtypeImage', ['valueType' => 'name', 'indexType' => '']) as $name) {
				$records = $_getRecords($name);
				foreach($records[0] as $uid) {
					if($uid) {
						if(isset($items[$uid])) {
							$counts['duplicate']++;
						}
						$items[$uid] = $uid;
					} else {
						$counts['missed']++;
					}
				}
				foreach($records[1] as $uid) {
					if(!$this->isImageVariant($uid)) {
						$counts['variations']++;
					}
				}
			}

			$counts['local'] = count($items) + $counts['missed'];

			return $counts;
		});

		$variants = $cache->getFor($this, 'usageVariants', WireCache::expireNever, function() use ($_getRecords) {

			$variants = [];
			foreach(array_keys($this->apiRequest('images/v1/variants', [], 'GET', false)['result']['variants'] ?? []) as $variant) {
				$variants[$variant] = [];
			}

			$existingVariants = array_keys($variants);

			foreach($this->wire()->fields->findByType('FieldtypeImage', ['valueType' => 'name', 'indexType' => '']) as $name) {
				foreach($_getRecords($name, true) as $variant) {
					if(!isset($variants[$variant][$name])) {
						$variants[$variant][$name] = 0;
					}
					$variants[$variant][$name]++;
				}
			}

			return [
				'variants' => $existingVariants,
				'usage' => $variants,
			];
		});

		$stream = $cache->getFor($this, 'usageStream', WireCache::expireNever, function() use ($_getRecords) {

			$counts = [];
			$result = $this->apiRequest('stream', [], 'GET', false);
			$counts['current'] = $result['result_info']['total_count'] ?? count($result['result'] ?? []);

			$items = [];
			$counts['missed'] = 0;
			$counts['duplicate'] = 0;
			foreach($this->wire()->fields->findByType('FieldtypeFile', ['valueType' => 'name', 'indexType' => '']) as $name) {
				foreach(explode(' ', $this->wire()->fields->get($name)->extensions) as $ext) {
					if(in_array($ext, explode(' ', self::streamExtensions))) {
						$records = $_getRecords($name);
						foreach($records[0] as $uid) {
							if($uid) {
								if(isset($items[$uid])) {
									$counts['duplicate']++;
								}
								$items[$uid] = $uid;
							} else {
								$counts['missed']++;
							}
						}
					}
				}
			}

			$counts['local'] = count($items) + $counts['missed'];

			return $counts;
		});

		$this->usage = [
			'imagesAllowed' => $images['allowed'] ?? 0,
			'imagesCount' => $images['current'] ?? 0,
			'imagesLocal' => $images['local'] ?? 0,
			'imagesVariations' => $images['variations'] ?? 0,
			'imagesDuplicate' => $images['duplicate'] ?? 0,
			'imagesMissed' => $images['missed'] ?? 0,
			'variants' => $variants['variants'] ?? [],
			'variantsUsage' => $variants['usage'] ?? [],
			'variantsAllowed' => self::maxVariants,
			'variantsCount' => count($variants['variants'] ?? []),
			'streamCount' => $stream['current'],
			'streamLocal' => $stream['local'] ?? 0,
			'streamDuplicate' => $stream['duplicate'] ?? 0,
			'streamMissed' => $stream['missed'] ?? 0,
		];

		return $this->usage;
	}

	/**
	 * Get the name (label) of this
	 *
	 * @param Pagefile $pagefile
	 * @return string
	 *
	 */
	public function ___getLabel(Pagefile $pagefile) {
		return $this->wire()->sanitizer->truncate($pagefile->description ?: $pagefile->page->title ?: $pagefile->basename, 1024);
	}

	/**
	 * List the images
	 *
	 * @param int $pageNum
	 * @return string
	 *
	 */
	public function listImages(int $pageNum = 1) {
		return $this->apiRequest(
			'images/v1?' . http_build_query([
				'page' => $pageNum,
				'per_page' => 10000,
			]),
			[],
			'GET'
		);
	}

	/**
	 * Remove a file from Cloudflare
	 *
	 * @param Pagefile $pagefile
	 * @return string|null
	 *
	 */
	public function removeFromCloudflare(Pagefile $pagefile) {

		$uid = $this->uid($pagefile);
		if($uid) {

			$useImages = $this->useImages($pagefile);

			$_delete = function($endpoint, $uid) {
				return $this->apiRequest(
					"$endpoint/$uid",
					[],
					'DELETE'
				);
			};

			$endpoint = $useImages ? 'images/v1' : ($this->useStream($pagefile) ? 'stream' : '');
			if($endpoint) {

				// Delete the item from Images / Stream
				$_delete($endpoint, $uid);

				if($useImages) {
					// Remove the uploaded image variants
					foreach($pagefile->getVariations() as $pageimageVariation) {
						$uidVariant = $this->uidVariant($pageimageVariation);
						if($uidVariant && !$this->isImageVariant($uidVariant)) {
							$_delete($endpoint, $uidVariant);
						}
					}
				}
			}

			// Remove the item from R2
			unlink($pagefile->r2Path);

			// Update statistics
			$this->resetUsage($endpoint);
		}

		// Remove filedata
		$pagefile = $this->removeUids($pagefile);

		return $uid;
	}

	/**
	 * Should Cloudflare Images be used for the Pagefile?
	 *
	 * @param Pagefile $pagefile
	 * @return bool
	 *
	 */
	public function useImages(Pagefile $pagefile) {
		return $this->accountHash && $pagefile instanceof Pageimage;
	}

	/**
	 * Should Cloudflare Stream be used for the Pagefile?
	 *
	 * @param Pagefile $pagefile
	 * @return bool
	 *
	 */
	public function useStream(Pagefile $pagefile) {
		return $this->customerSubdomain &&
			!$this->useImages($pagefile) &&
			in_array($pagefile->ext, explode(' ', self::streamExtensions));
	}

	/**
	 * Download the file from R2 if it does not exist locally
	 *
	 * @param Pagefile $pagefile
	 * @return int|bool
	 *
	 */
	protected function downloadRemoteFile(Pagefile $pagefile) {

		// If this is an image variation
		// It is the original image we need to download
		if($pagefile instanceof Pageimage && $pagefile->isVariation($pagefile->basename)) {
			$pagefile = $pagefile->getOriginal();
		}

		$localFile = $pagefile->filename;
		$remoteFile = $pagefile->r2Path;

		$downloaded = false;
		if(!file_exists($localFile) && file_exists($remoteFile)) {
			$downloaded = $this->wire()->files->filePutContents($localFile, fopen($remoteFile, 'r'));
		}

		return $downloaded;
	}

	/**
	 * Add the image to Cloudflare
	 *
	 * @param Pageimage $pageimage
	 * @param $url
	 * @return string|null
	 *
	 */
	protected function addImageToCloudflare(Pageimage $pageimage, $url = '') {

		if(empty($url)) {
			$url = $pageimage->localHttpUrl;
		}

		$boundary = '--' . self::formDataBoundary;
		$response = $this->apiRequest(
			'images/v1',
			"$boundary\r\n" .
			"Content-Disposition: form-data; name=\"url\"\r\n\r\n{$url}\r\n" .
			"$boundary--\r\n\r\n"
		);

		return $response['result']['id'] ?? null;
	}

	/**
	 * Get the image variant name
	 *
	 * Remove the prefix
	 *
	 * @param string $variant
	 * @return bool
	 *
	 */
	protected function getImageVariantName($variant) {
		return str_replace(self::imageVariantPrefix, '', $variant);
	}

	/**
	 * Is this variant name an image variant?
	 *
	 * @param string $variant
	 * @return bool
	 *
	 */
	protected function isImageVariant($variant) {
		return substr($variant, 0, strlen(self::imageVariantPrefix)) === self::imageVariantPrefix;
	}

	/**
	 * Start a ProfilerPro timer
	 *
	 * #pw-group-utility
	 *
	 * @param string $name Name of your event.
	 * @return array|null Event to be used for stop call.
	 *
	 */
	protected function profilerStart($name) {
		return $name && $this->wire()->profiler ? $this->wire()->profiler->start("{$this->className}::$name") : null;
	}

	/**
	 * Stop a ProfilerPro timer
	 *
	 * #pw-group-utility
	 *
	 * @param array|object|string|null $event The event returned from the $profiler->start() method.
	 * @return float Returns elapsed time since the start() call.
	 *
	 */
	protected function profilerStop($event) {
		return $event && $this->wire()->profiler ? $this->wire()->profiler->stop($event) : 0;
	}

	/**
	 * Remove the Cloudflare UIDs from a Pagefile
	 *
	 * @param Pagefile $pagefile
	 * @return Pagefile
	 *
	 */
	protected function removeUids($pagefile) {
		$filedata = $pagefile->filedata();
		foreach($filedata as $key => $value) {
			if(strpos($key, $this->className) === 0) {
				$pagefile->filedata(null, $key);
			}
		}
		return $pagefile;
	}

	/**
	 * Reset usage
	 *
	 * @param string $key
	 * @return int
	 *
	 */
	protected function resetUsage($key) {
		// Remove cached usage stats
		$this->wire()->cache->deleteFor($this, 'usage' . ucfirst(explode('/', $key)[0]));
		// Get them again
		return $this->getUsageStatistics()["{$key}Count"] ?? 0;
	}

	/**
	 * Save a Pagefile's Page quietly
	 *
	 * This is used for saving Pagefile::filedata
	 *
	 * @param Pagefile $pagefile
	 * @return bool
	 *
	 */
	protected function saveQuietly(Pagefile $pagefile) {
		return $this->wire()->pages->___save($pagefile->page, [
			'noHooks' => true,
			'quiet' => true,
		]);
	}

	/**
	 * Set the filedata for a Pagefile immediately
	 *
	 * @param Pagefile $pagefile
	 * @param string $uidVariant
	 * @return Pagefile
	 *
	 */
	protected function setFiledataImmediately(Pagefile $pagefile, $uidVariant) {

		$page = $this->wire()->pages->get($pagefile->page->id);

		$of = $page->of();
		$page->of(false);
		foreach($page->get($pagefile->field->name) as $pf) {
			if($pf->basename === $pagefile->original->basename) {
				$pf->page->of(false);
				$this->uidVariant($pf, $pagefile->basename, $uidVariant);
				$this->saveQuietly($pf);
				$pagefile->filedata($pf->filedata());
			}
		}
		$page->of($of);

		return $pagefile;
	}

	/**
	 * Get/set the UID in filedata
	 *
	 * @param Pagefile $pagefile
	 * @param mixed $value
	 * @return mixed
	 * @see Pagefile::filedata()
	 *
	 */
	protected function uid(Pagefile $pagefile, $value = null) {
		return $pagefile->filedata($this->className, $value);
	}

	/**
	 * Get/set the variant UID in filedata
	 *
	 * @param Pageimage $pageimage
	 * @param string $basename
	 * @param mixed $value
	 * @return mixed
	 * @see Pagefile::filedata()
	 *
	 */
	protected function uidVariant(Pageimage $pageimage, $basename = '', $value = null) {
		if(empty($basename)) $basename = $pageimage->basename;
		return $pageimage->filedata("{$this->className}_{$basename}", $value);
	}
}
